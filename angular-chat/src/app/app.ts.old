/**
 * ANGULAR CHAT - MAIN APP COMPONENT
 *
 * NOTICE THE ANGULAR DIFFERENCES:
 * 1. ‚úÖ TypeScript - Type safety built-in (not optional like React)
 * 2. ‚úÖ Decorators - @Component, @Injectable (metadata-driven)
 * 3. ‚úÖ Dependency Injection - Services injected automatically
 * 4. ‚úÖ Signals - New reactive primitive (Angular 16+)
 * 5. ‚úÖ Template Syntax - HTML with Angular directives
 * 6. ‚úÖ Opinionated - Angular tells you HOW to structure
 *
 * MVC ROLES IN ANGULAR:
 * - Component = Controller (handles logic)
 * - Template = View (HTML file)
 * - Services = Model (data & business logic)
 * - Clear separation of concerns!
 */

import { Component, OnInit, OnDestroy, signal, effect } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

// Interface for type safety - TypeScript!
interface ChatMessage {
  type: string;
  text?: string;
  message?: string;
  sender?: string;
  implementation?: string;
  mentionedImplementation?: string;
  timestamp: string;
}

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './app.html',
  styleUrl: './app.css'
})
export class App implements OnInit, OnDestroy {
  // =========================================================================
  // SIGNALS - Angular's Reactive State Management
  // Signals auto-update the template when changed!
  // Compare to React's useState - but more powerful
  // =========================================================================

  messages = signal<ChatMessage[]>([]);
  inputValue = signal<string>('');
  isConnected = signal<boolean>(false);

  private websocket: WebSocket | null = null;

  // =========================================================================
  // LIFECYCLE HOOKS (Controller)
  // Angular has explicit lifecycle - very structured!
  // ngOnInit = componentDidMount in React
  // ngOnDestroy = cleanup in useEffect
  // =========================================================================

  ngOnInit(): void {
    console.log('üöÄ Angular Chat starting...');
    this.connectWebSocket();
  }

  ngOnDestroy(): void {
    console.log('üõë Angular Chat closing...');
    this.websocket?.close();
  }

  // =========================================================================
  // WEBSOCKET CONNECTION (Controller Logic)
  // =========================================================================

  private connectWebSocket(): void {
    this.websocket = new WebSocket('ws://localhost:3000');

    this.websocket.onopen = () => {
      console.log('‚úÖ Connected to WebSocket server');

      // Update signal - Angular auto-updates template!
      this.isConnected.set(true);

      // Send implementation info
      this.websocket?.send(JSON.stringify({
        implementation: 'angular',
        text: 'Angular chat user connected'
      }));

      this.addSystemMessage('Connected to chat server');
    };

    this.websocket.onmessage = (event) => {
      try {
        const data: ChatMessage = JSON.parse(event.data);

        if (data.type === 'system') {
          this.addSystemMessage(data.message || '');
        } else if (data.type === 'message') {
          this.addChatMessage(data);
        }
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    };

    this.websocket.onclose = () => {
      console.log('üî¥ Disconnected from WebSocket server');
      this.isConnected.set(false);
      this.addSystemMessage('Disconnected from server');
    };

    this.websocket.onerror = (error) => {
      console.error('‚ùå WebSocket error:', error);
      this.addSystemMessage('Connection error occurred');
    };
  }

  // =========================================================================
  // MESSAGE MANAGEMENT (Controller Logic)
  // Notice: We update signals, Angular handles the view!
  // =========================================================================

  private addSystemMessage(text: string): void {
    this.messages.update(msgs => [...msgs, {
      type: 'system',
      message: text,
      timestamp: new Date().toISOString()
    }]);
  }

  private addChatMessage(data: ChatMessage): void {
    this.messages.update(msgs => [...msgs, data]);
  }

  // =========================================================================
  // USER ACTIONS (Controller - called from template)
  // These are public methods called from the HTML template
  // =========================================================================

  sendMessage(): void {
    const text = this.inputValue().trim();

    if (!text) return;

    if (!this.isConnected()) {
      alert('Not connected to server!');
      return;
    }

    // Send message
    this.websocket?.send(JSON.stringify({
      text: text,
      sender: 'Angular User',
      implementation: 'angular',
      timestamp: new Date().toISOString()
    }));

    // Clear input - signal updates template automatically!
    this.inputValue.set('');
  }

  onKeyPress(event: KeyboardEvent): void {
    if (event.key === 'Enter') {
      this.sendMessage();
    }
  }

  // =========================================================================
  // HELPER METHODS (View Logic)
  // Used in the template for formatting
  // =========================================================================

  formatTime(timestamp: string): string {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit'
    });
  }
}

/**
 * SUMMARY: WHAT ANGULAR PROVIDES (vs React & Vanilla)
 *
 * 1. ‚úÖ TYPESCRIPT FIRST: Strong typing built-in
 * 2. ‚úÖ DEPENDENCY INJECTION: Professional architecture pattern
 * 3. ‚úÖ OPINIONATED STRUCTURE: Clear way to organize code
 * 4. ‚úÖ SIGNALS: Powerful reactive state management
 * 5. ‚úÖ DECORATORS: Metadata-driven programming
 * 6. ‚úÖ CLEAR SEPARATION: Component (logic) + Template (view) + Service (model)
 * 7. ‚úÖ LIFECYCLE HOOKS: Explicit component lifecycle
 * 8. ‚úÖ BUILT-IN FEATURES: Forms, HTTP, routing all included
 * 9. ‚úÖ ENTERPRISE READY: Made for large applications
 * 10. ‚úÖ CLI TOOLS: Powerful code generation
 *
 * TRADE-OFFS (vs React):
 * ‚ùå STEEPER LEARNING CURVE: More concepts to learn
 * ‚ùå MORE VERBOSE: More boilerplate code
 * ‚ùå BIGGER BUNDLE: Framework is larger
 * ‚ùå LESS FLEXIBLE: Opinionated = less freedom
 * ‚úÖ BUT: Better for large teams, enterprise apps
 */
